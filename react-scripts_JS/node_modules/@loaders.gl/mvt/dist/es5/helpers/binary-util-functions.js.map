{"version":3,"sources":["../../../src/helpers/binary-util-functions.ts"],"names":["classifyRings","geom","len","lines","length","data","areas","polygons","ringAreas","polygon","ccw","offset","endIndex","i","startIndex","shape","slice","area","before","after","concat","undefined","push","project","x0","y0","size","j","jl","y2","Math","PI","atan","exp","readFeature","tag","feature","pbf","id","readVarint","readTag","type","_geometry","pos","end","key","_keys","value","_values","properties"],"mappings":"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","sourcesContent":["import Protobuf from 'pbf';\nimport {getPolygonSignedArea} from '@math.gl/polygon';\nimport {MvtBinaryGeometry} from '../lib/types';\nimport VectorTileFeature from '../lib/binary-vector-tile/vector-tile-feature';\n\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * The function also detects holes which have zero area and\n * removes them. In doing so it modifies the input\n * `geom.data` array to remove the unneeded data\n *\n * @param geometry\n * @returns object\n */\n// eslint-disable-next-line max-statements\nexport function classifyRings(geom: MvtBinaryGeometry) {\n  const len = geom.lines.length;\n\n  if (len <= 1) {\n    return {\n      data: geom.data,\n      areas: [[getPolygonSignedArea(geom.data)]],\n      lines: [geom.lines]\n    };\n  }\n\n  const areas: any[] = [];\n  const polygons: any[] = [];\n  let ringAreas: number[] = [];\n  let polygon: number[] = [];\n  let ccw: boolean | undefined;\n  let offset = 0;\n\n  for (let endIndex: number, i = 0, startIndex: number; i < len; i++) {\n    startIndex = geom.lines[i] - offset;\n\n    endIndex = geom.lines[i + 1] - offset || geom.data.length;\n    const shape = geom.data.slice(startIndex, endIndex);\n    const area = getPolygonSignedArea(shape);\n\n    if (area === 0) {\n      // This polygon has no area, so remove it from the shape\n      // Remove the section from the data array\n      const before = geom.data.slice(0, startIndex);\n      const after = geom.data.slice(endIndex);\n      geom.data = before.concat(after);\n\n      // Need to offset any remaining indices as we have\n      // modified the data buffer\n      offset += endIndex - startIndex;\n\n      // Do not add this index to the output and process next shape\n      continue; // eslint-disable-line no-continue\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon.length) {\n        areas.push(ringAreas);\n        polygons.push(polygon);\n      }\n      polygon = [startIndex];\n      ringAreas = [area];\n    } else {\n      ringAreas.push(area);\n      polygon.push(startIndex);\n    }\n  }\n  if (ringAreas) areas.push(ringAreas);\n  if (polygon.length) polygons.push(polygon);\n\n  return {areas, lines: polygons, data: geom.data};\n}\n\n/**\n *\n * @param data\n * @param x0\n * @param y0\n * @param size\n */\nexport function project(data: number[], x0: number, y0: number, size: number): void {\n  for (let j = 0, jl = data.length; j < jl; j += 2) {\n    data[j] = ((data[j] + x0) * 360) / size - 180;\n    const y2 = 180 - ((data[j + 1] + y0) * 360) / size;\n    data[j + 1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n  }\n}\n\n/**\n * All code below is unchanged from the original Mapbox implemenation\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nexport function readFeature(tag: number, feature?: VectorTileFeature, pbf?: Protobuf): void {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();\n    else if (tag === 2) readTag(pbf, feature);\n    else if (tag === 3) feature.type = pbf.readVarint();\n    else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\n\n/**\n * @param pbf\n * @param feature\n */\nexport function readTag(pbf: Protobuf, feature: VectorTileFeature): void {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n    const value = feature._values[pbf.readVarint()];\n    feature.properties[key] = value;\n  }\n}\n"],"file":"binary-util-functions.js"}